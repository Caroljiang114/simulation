---
title: "STAT321/421"
author: "Gregory J. Matthews"
format: revealjs
editor: visual
execute: 
  echo: true
---

# Useful Links

-   [Installing R and RStudio](https://36-sure.github.io/r-setup.html)

-   [Setting up Git and Github](https://36-sure.github.io/git-setup.html)

-   [Quarto](https://r4ds.hadley.nz/quarto)

-   [Piazza Course Site](https://piazza.com/class/lzyfs2usjv2e6)

-   [Dr. Matthews' Zoom link](https://luc.zoom.us/j/6622906748)

-   [Advanced R](https://adv-r.hadley.nz/)

-   [R for Data Science](https://r4ds.had.co.nz/)

## R Data types and operators

-   Tensors (Vectors, Matrices, Arrays)
-   Lists
-   Data Frames

## Vectors

-   Basic unit of R
-   All elements must be same type
-   Types of vectors:
    -   Numeric
    -   Integer
    -   Character
    -   Logical

## Examples

```{r}
#| echo: true
v1 <- c(413,508,603,860,312)
class(v1)

v2 <- as.integer(c(413,508,603,860,312))
class(v2)

v3 <- c("rock","guts","agrocrag","trash", "spritecoin", "hai davai")
class(v3)

v4 <- c(TRUE, FALSE, TRUE)
class(v4)

v5 <- as.factor(c(103,112,119,125,13))
class(v5)
```

## Operations

All operations are done element wise

```{r}
#| echo: true
#addition
v1 + v2

#substraction
v1 - v2

#Multiplication
v1 * v2

#Division
v1 / v2

# Powers
v1^2

# Remainder 
v1 %% 2

```

## Operations

```{r}
#| echo: true
sum(v1)
```

## Subsetting a vector

Vectors have a single index

```{r}
#| echo: true
#pull out a single element
v1[1]

#pull out consecutive elements
v1[2:4]

#remove an element
v1[-2]

#remove consecutive elements
v1[-c(3:4)]

#pull out nonconsecutive elements
v1[c(1,3,5)]
```

## Some useful functions

```{r}
#Repeat something n times
rep(3, 7)
rep("G", 3)

#create a sequence
seq(1,10,4)
seq(1,10,length = 3)
```


## Matrices
  
 - Still only one type of data allowed 
 - Matrices have two indices 

```{r}
m1 <- matrix(c(5,6,9,3), ncol = 2)
m1
dim(m1)
class(m1)
```

## Matrices

```{r}
m2 <- matrix(c("greg","quang","bob","nick"), ncol = 2)
m2
class(m2)

m3 <- matrix(c(TRUE, FALSE, FALSE, FALSE), ncol = 2)
m3
class(m3)

```

## Subsetting a matrix

 - Rows first, columns second
 
```{r}
#Selecting a single element
m2[2,2]

#Selecting a single row
m2[1,]

#Selecting a single column
m2[,1]

```

## Arrays

 - Arrays can have more than two indices
 - But still only one type of data is allow

```{r}
a1 <- array(runif(12),dim = c(3,2,2))
a1
```

## Arrays
```{r}
dim(a1)
class(a1)
```


## Subsetting an array

```{r}
#Single element
a1[1,2,2]

#Some examples
a1[1,,]

a1[,1,]

a1[,,1]
```

## Lists
 - Those are all nice, but I want to store more than one type of data
 - How do I do that?  
 - Lists!
 - Lists allow for multiple types of data to be stored in a single object.  
 - Lists are recursive objects (i.e. an element of a list can be a list itself.  Convince yourself this is not true for vectors.)
 
## Lists 
```{r}
#Creating a list 
l1 <- list(1, "spam", TRUE)
l1
class(l1)
```

## Subsetting a list
 - Lists are indexed by double brackets
 
```{r}
l1[[1]]
l1[[2]]
l1[[3]]
```

## Naming elements of a list 
 - You can name elements of a list
```{r}
l2 <- list(number = 1, email = "spam", win = TRUE)
l2
class(l2)
```

## Subsetting a list
 - Now you can subset my index number or name 
```{r}
names(l2)

#These all do the same thing now
l2[['number']]
l2[[1]]
l2$number

#This is how you do it, Sebastian.
#purrr::keep_at(l2, c(1,3))
```
 
## Data Frames

 - Data frames are matrices
 - Data frames are (special) lists
  - Every element of the list is a vector of the same length.  
  
```{r}
d1 <- data.frame(v1 = 1:5, 
                 v2 = seq(1,10,2),
                 v3 = c("trench","container","food","comptroller","mic"))
d1
class(d1)
```

## Subsetting a data frame
 - Data frames act like matrices
 - Data frames act like lists

```{r}
#single row
d1[1,]

#single column
d1[,3]
d1[[3]]
d1$v3
d1[["v3"]]
```

## Adding rows and columns to a data frame
 - Adding a row
```{r}
library(tidyverse)
d2 <- data.frame(v1 = 6:10, v2 = seq(11,20,2) , v3 = c("a","b","c","d","e"))
rbind(d1, d2)
bind_rows(d1,d2)
```

## Adding rows and columns to a data frame

 - bind_rows is better because the names don't need to match!
```{r}

d2 <- data.frame(v1 = 6:10, v2 = seq(11,20,2) , v4 = c("a","b","c","d","e"))
try(rbind(d1, d2))
bind_rows(d1,d2)
```

## Adding rows and columns to a data frame

 - Adding a new column
```{r}
d1$v5 <- rnorm(5) 
d1
```

## Logical statements
 
 - Returns TRUE or FALSE
  - equal: ==
  - less than or equal: <=
  - less than: <
  - greater than or equal: >=
  - greater than: >
  - not equal: != 
 

## Logical statements
 
```{r}
#Examples
#Note: a = 3 assigns the value of 3 to a.  
a <- 3
a == 3
a > 5
a != 2
a <= 3

```

## Logical statements
 - and: &
 - or: |
 - not: !
```{r}
#Examples
b <- 10
(a == 3) & (b == 5)
(a != 4) | (b >= 10)
```


## Subsetting vectors with logical statements
```{r}
v1 > 500

v1[v1 > 500]

v1[v1 != 413 & v1 < 700]

#Special operator %in%
v1 %in% c(413,508)
```

  
 
